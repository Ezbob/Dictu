import Inspect;

abstract class UnitTest {
    var METHOD_NAME_PADDING = '    ';
    var RESULTS_PADDING     = '    ';
    var ASSERTION_PADDING   = '         ';
    var results = {
        'passed': 0,
        'failed': 0,
        'skipped': 0
    };

    init(private onlyFailures = false, private exitOnFailure = false) {}

    filterMethods() {
        return this.methods().filter(def (method) => {
            if (method.startsWith('test') and !method.endsWith('Provider') and !method.endsWith('_skipped')) {
                return method;
            }

            if (method.endsWith('_skipped')) {
                this.results['skipped'] += 1;
            }
        });
    }

    setUp() {

    }

    tearDown() {

    }

    run() {
        const methods = this.filterMethods();

        // TODO: This needs fixing
        print(__file__);
        methods.forEach(def (method) => {
            print('{}{}()'.format(UnitTest.METHOD_NAME_PADDING, method));
            this.setUp();

            const providerMethodName = '{}Provider'.format(method);

            if (this.hasAttribute(providerMethodName)) {
                const testValue = this.getAttribute(providerMethodName)();

                if (type(testValue) == 'list') {
                    testValue.forEach(def (val) => {
                        this.getAttribute(method)(val);
                    });
                } else {
                    this.getAttribute(method)(testValue);
                }
            } else {
                this.getAttribute(method)();
            }


            this.tearDown();
        });
        print('\nResults:\n{}- {} assertion(s) were successful.\n{}- {} assertion(s) were failures.\n{}- {} method(s) were skipped.\n'.format(
            UnitTest.RESULTS_PADDING,
            this.results['passed'],
            UnitTest.RESULTS_PADDING,
            this.results['failed'],
            UnitTest.RESULTS_PADDING,
            this.results['skipped']
        ));
    }

    printResult(success, errorMsg) {
        if (success) {
            this.results['passed'] += 1;

            if (!this.onlyFailures) {
                print('{}Success.'.format(UnitTest.ASSERTION_PADDING));
            }
        } else {
            this.results['failed'] += 1;

            print('{}Line: {} - {}'.format(UnitTest.ASSERTION_PADDING, Inspect.getLine(2), errorMsg));

            if (this.exitOnFailure) {
                System.exit(1);
            }
        }
    }

    assertEquals(value, expected) {
        this.printResult(value == expected, 'Failure: {} is not equal to {}.'.format(value, expected));
    }

    assertTruthy(value) {
        this.printResult(value, 'Failure: {} is not Truthy.'.format(value));
    }

    assertFalsey(value) {
        this.printResult(!value, 'Failure: {} is not Falsey.'.format(value));
    }

    assertSuccess(value) {
        if (type(value) != 'result') {
            this.printResult(false, 'Failure: {} is not a Result type.'.format(value));
            return;
        }

        this.printResult(value.success(), 'Failure: {} is not a Result type in a success state.'.format(value));
    }

    assertError(value) {
        if (type(value) != 'result') {
            this.printResult(false, 'Failure: {} is not a Result type.'.format(value));
            return;
        }

        this.printResult(!value.success(), 'Failure: {} is not a Result type in an error state.'.format(value));
    }
}